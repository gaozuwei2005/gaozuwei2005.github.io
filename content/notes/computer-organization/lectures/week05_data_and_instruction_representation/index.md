---
title: 计算机组成原理 | 课堂笔记 | Week 5 数据表示、指令表示
date: 2025-10-09
toc: true
summary: 数据对齐、数据纠错、指令类型、MIPS指令系统
---
# 2.4 计算机中的数据表示 (con'd)

## 2.4.6 数据的度量与存储

**数据对齐**：假设字的宽度为 32 位（4 字节），按字节编址，那么
- **双字地址**（如 `double` 8 字节）：首地址放在 8 的倍数
- **字地址**（如 `int` 4 字节）：首地址放在 4 的倍数
- **半字地址**（如 `short` 2 字节）：首地址放在 2 的倍数
- **字节地址**（如 `double` 1 字节）：地址可随意

对齐访问：访问一个 4 字节的字时，其首地址必须是 4 的倍数。

非对齐访问：其首地址不一定是 4 的倍数，**但是速度较慢**。

如果数据不对齐时，读取多字节数据的时候，可能需要访存多次或者使用非对齐访问才能读取完整数据。

## 2.4.7 数据的检错 / 纠错

**奇偶校验码**：

步骤：在源部件和目的部件求出奇偶校验位 $P, P''$，检查 $P = P''$

优缺点：
- 只能发现奇数位出错，不能发现偶数位出错，而且也不能确定发生错误的位置，不具有纠错能力
- 开销小，适用于校验一字节长的代码，故常被用于存储器读写检查或按字节传输过程中的数据校验

## 2.4.8 基本指令和指令类型

**指令系统**：数据传送、运算、输入输出、系统控制、程序控制

**数据传送指令**：参数有原地址 + 目的地址

**原子操作**（？）：用一个内存单元存储一个锁的状态，在读写数据的时候，要先访问锁的状态是否为 $0$，才能继续访问内存单元，防止多个进程同时访问同一内存单元。

**子程序调用和返回指令**：
- 函数间转返：分为 `CALL` 和 `RETURN` 两种指令。为了解决函数嵌套和递归的调用，使用**堆栈**来保存返回的地址。常使用 *基址偏移寻址*。
- 参数传递：约定寄存器、约定存储单元、参数赋值、堆栈法
- 公用寄存器：...

**子程序的运行步骤**：
- 保存子程序运行时即将破坏的寄存器内容
- 从特定位置取输入参数
- 加工处理
- 将结果送到特定位置
- 恢复被破坏的寄存器内容
- 返回主程序
# 2.5 程序的机器级表示
## 2.5.1 MIPS 指令系统介绍

**MIPS 指令格式**：都是32位宽，按字地址对齐

**R-Type**：`op rs rt rd shamt funct`

| 字段代号    | 名称          | 位长  |
| ------- | ----------- | --- |
| `op`    | 操作码         | 6   |
| `rs`    | 第一个源操作数寄存器  | 5   |
| `rt`    | 第二个源操作数寄存器  | 5   |
| `rd`    | 存放目的结果的寄存器  | 5   |
| `shamt` | 位移量         | 5   |
| `funct` | 功能码，用于操作码拓展 | 6   |

**I-Type**：`op rs rt immediate`

| 字段代号        | 名称         | 位长  |
| ----------- | ---------- | --- |
| `op`        | 操作码        | 6   |
| `rs`        | 第一个源操作数寄存器 | 5   |
| `rt`        | 第二个源操作数寄存器 | 5   |
| `immediate` | 立即数或者偏移地址  | 16  |

 **J-Type**：`op target-address`

| 字段代号             | 名称                                                                            | 位长  |
| ---------------- | ----------------------------------------------------------------------------- | --- |
| `op`             | 操作码                                                                           | 6   |
| `target-address` | `JumpAddr = [PC[31:28], target-address, 00]`<br>其中 `PC` 是当前指令地址 $+4$（下一条指令地址） | 26  |
